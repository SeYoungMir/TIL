# 5. 크롤러 설계/개발(응용)
## 6. 병렬 처리할 때의 주의점
### 1. 병렬 처리할 때 주의해야 하는 점
- 병렬 처리는 순차 처리와 패러다임 자체가 다르기 때문에 여러가지 주의해야 할 부분이 있음. 기본적인 주의점부터 확인
1. 태스크 워크 플로우 디자인
   - 의존 관계가 있는 태스크를 함께 처리하면 어떤 태스크가 부모가 되고, 부모 태스크가 자식 태스크(서브 태스크)를 호출하는 설계가 됨
   - 가능하면 부모 태스크가 자식 태스크의 실행 결과를 기다리지 않게 설계하는 것이 좋음
   - 단순한 태스크들을 연결해서 사용할 때는 거의 문제되지 않지만, 처리에 종속성이 있으면 병렬 처리의 주된 목적이라고 할 수 있는 실행 효율이 의도한 것만큼 나오지 않을 수 잇음.
   - 이처럼 종속성이 있는 처리를 만들 경우 Celery를 사용할 때 chord 함수와 group 함수를 사용하게 됨. 처리가 굉장히 복잡해질 수 있으며, 처리가 복잡해지면 코드가 복잡해지고, 디버깅도 어려워짐. 너무 복잡하다고 느끼게 되면 설계를 다시 검토해보는 것이 좋을 수 있음
2. 데이터 전달
   - 큐와 워커끼리의 데이터 교환은 직렬화된 객체만 가능하므로 주의
   - 상태를 가진 클래스의 인스턴스 자체를 줄 수 없음. 따라서 태스크의 매개 변수를 최대한 단순하게 설정하는 것이 좋음
3. 데이터충돌
   - 멀티 스레드 처리를 할 때는 변수의 충돌, 멀티 프로세스 처리를 할 때는 파일과 데이터베이스 레코드 충돌의 주의
   - Celery 예제에서는 워커의 로그 파일을 따로따로 기록, 만약 하나의 로그파일에 기록한다면 동시에 파일에 접근하는 문제가 발생해서 의도하지않은 로그가 될 수 있음.
   - 같은 위치에 로그를 기록하고 싶을 때에는 Fluentd와 Sentry 같은 로그 전용 미들웨어의 검토필요
   - Logging Cookbook[(URL)](https://docs.python.org/3/howto/logging-cookbook.html)참고
   - 일반적으로 하나의 애플리케이션에는 하나의 데이터 베이스 사용
   - 트랜잭션 처리로 변경할 레코드가 중복되면 데드락(deadlock)오류 발생. versions 칼럼 또는 timestamp 칼럼으로 낙관적 잠금(Optimistic locking)을 사용한 배타적 갱신 처리 구현, MySQL에서는 INSERT ... ON DUPLICATE KEY UPDATE 구문, PostgreSQL이라면 UPSERT ... ON CONFLICT 구문 사용해서 대처
   - 데이터 충돌을 피할때 Redis와 memcashed를 사용, Mutex를 구현하는 것도 방법, 데이터베이스 처리와 관련된 정합성 확보, 알고리즘은 또 다른 전문적 분야 이야기.
4. 상태 관리
   - 예제는 로그로 태스크 실행 상태 판단 가능, 하지만 로그는 계속 기록되는 것이므로 작업이 어떤 상태를 나타내는지 한번에 확인 어려움.
   - 또한 많은 URL을 수집하는 크롤러를 운용하다보면 불필요한 URL이 수집되는 경우 있음
   - 위와 같은 경우 데이터베이스로 URL의 상태(수집or 미수집)등을 함께 기록해 크롤러 관리 가능.