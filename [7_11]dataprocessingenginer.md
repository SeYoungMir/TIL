### 2. 물리 데이터저장소 구성
#### 1. 테이블 제약조건
- 참조된 기본 키의 값이 삭제될 경우 처리내용을 정의하는 'Delete constraint'와 참조된 기본 키의 값이 수정될 경우의 처리 내용을 정의하는 'Update constraint'두 가지
  1. Delete Constraint
     1. Cascade: 참조된 테이블의 외부 키와 일치하는 모든 Row 삭제
     2. Restricted: 참조된 테이블의 외부 키에 없는 것만 삭제 가능
     3. Nullify: 참조된 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정
  2. Update Constraint
     1. Cascade: 참조된 테이블의 외부 키와 일치하는 모든 Row 수정
     2. Restricted: 참조된 테이블의 외부 키에 없는 것만 수정 가능
     3. Nullify: 참조된 테이블에 정의된 외부 키와 일치하는 것을 Null로 수정
#### 2. 인덱스 설계
1. 인덱스 적용 기준
   1. 인덱스 칼럼 분포도 10~15% 이내인 경우
      - 분포도=(1/칼럼 값의 종류)$\times$ 100=(칼럼 값의 평균 Row수/테이블의 총 Row 수)$\times$ 100
   2. 분포 범위 이상이더라도 부분처리를 목적으로 하는 경우
   3. 조회 및 출력 조건으로 사용되는 칼럼일 경우 적용
   4. 인덱스 자동생성 기본키와 Unique 키의 제약조건을 사용할 경우 적용
2. 인덱스 칼럼 선정
   1. 분포도가 좋은 칼럼은 단독 생성하여 활용도 향상
   2. 결합 인덱스 생성을 통해 자주 조합되어 사용되는 칼럼 활용
   3. 사용빈도, 유일성 등 결합 인덱스에 구성되는 순서 선정에 유의
   4. 가능한 자주 수정이 되지 않도록 유의하여 선정
3. 설계 시 고려사항
   1. 신규 추가 인텍스가 기존 인덱스 경로에 영향을 주지 않도록 유의
   2. 오버헤드 작용은 지나치게 많은 인덱스로 인해 발생.
   3. 추가적인 저장공간이 필요함을 항상 염두
   4. 인덱스와 데이터의 저장공간 분리되도록 설계
   5. 많은 범위를 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드 발생 가능성 유의
#### 3. 뷰 설계
1. 뷰 속성
<table>
    <tr>
        <th>속성</th>
        <th>내용</th>
    </tr>
    <tr>
        <td>REPLACE</td>
        <td>뷰가 이미 존재하는 경우 재생성</td>
    </tr>
    <tr>
        <td>FORCE</td>
        <td>기본 테이블의 존재 여부에 관계 없이 뷰 생성</td>
    </tr>
    <tr>
        <td>NOFORCE</td>
        <td>기본 테이블이 존재할 때 뷰 생성</td>
    </tr>
    <tr>
        <td>WITH CHECK OPTION</td>
        <td>Sub-Qurey내의 조건을 만족하는 행만 변경</td>
    </tr>
    <tr>
        <td>WITH READ ONLY</td>
        <td>데이터 조작어 작업 불가</td>
    </tr>
    
</table>

2. 뷰 설계시 고려사항
   1. 뷰 사용에 따라 수행속도에 문제 발생 가능
   2. SELECT문의 조건은 가능한 한 최적의 액세스 경로를 사용하고 뷰를 사용한 SQL의 WHERE 절에서는 반드시 양호한 액세스 경로가 되도록 해야함
#### 4. 클러스터 설계
1. 적용 기준
   1. 대량의 범위를 자주 액세스하는 경우에 적용
   2. 다수의 테이블이 빈번하게 조인을 일으킬 때 활용
   3. 다중 블록 이상의 테이블에 적용
   4. 액세스 효율 향상을 위한 물리적 저장 방법
   5. 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능
   6. 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용
   7. 인덱스의 단점을 해결하여 분포도가 넓을수록 유리
   8. 반복 칼럼이 정규화에 의하여 어쩔 수 없이 분할된 경우 활용
2. 클러스터 설계 시 고려사항
   1. 검색 효율은 높여주지만 입력, 수정, 삭제 시 부하 증가를 고려해야 함
   2. Union, Distinct, Order by, Group by가 빈번한 칼럼, 자주 수정이 발생하지 않는 칼럼이 고려 대상
   3. 처리 범위가 넓어 문제가 발생할 경우 단일 테이블 클러스터링을 고려
   4. 조인이 많아 문제가 발생하는 경우 다중 테이블 클러스터링을 고려
#### 5. 파티션 설계
1. 파티션 종류
   1. 범위분할(Range Partitioning): 지정한 열의 값을 기준으로 분할
   2. 해시 분할(Hash Partitioning): 해시 함수에 따라 데이터를 분할
   3. 조합 분할(Composite Partitioning): 범위 분할에 의하여 데이터를 분할 한 후 해시 함수를 적용하여 재분할
2. 장점
   1. 데이터 엑세스 범위를 줄여 성능 향상
   2. 전체 데이터의 훼손 가능성이 감소 및 데이터 가용성 향상
   3. 분할 영역을 독립적으로 백업하고 복구 가능
   4. Disk Striping을 통한 I/O 성능 향상
3. 파티셔닝 순서
   1. 파티선 종류 결정
   2. 파티션 키의 선정
   3. 파티션 수의 결정
#### 6. 디스크 구성 설계
   1. 정확한 용량 산정은 디스크 사용 효율을 향상시킴
   2. 업무량이 집중되어 있는 디스크를 분리 설계를 통한 집중화된 디스크의 부하를 분산
   3. 입출력 경합을 최소화하여 데이터 접근성을 향상
      - 테이블을 마스터 테이블과 트랜잭션 테이블로 분류
      - 테이블 스페이스와 템포러리 스페이스를 분리하여 구성
      - 테이블 객체를 위한 테이블 스페이스와 인덱스 객체를 위한 테이블 스페이스를 분리하여 구성
   4. 시스템 구성에 따라 테이블 공간의 수와 크기 결정
   5. 파티션 할 테이블은 별도 분류