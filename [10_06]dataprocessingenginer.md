## 1. 운영체제 기초 활용하기
### 3. 운영체제 핵심 기능
1. 주소 지정 방식
   1. 연산자(operation code)
      - 명령어는 크게 연산자(operation : 동작 부분), 자료(operand : 주소 부분)로 구성
       - op-code | operand 순으로 구성
   2.  주소 지정 명령어 형식
       1.  0주소 방식 OP code > stack에 저장
       2.  1주소 방식 OP code |Operand1 > 누산기에 저장
       3.  2주소 방식 OP code |Operand1|Operand2 >범용 레지스터 이용
       4.  3주소 방식 OP code |Operand1|Operand2|Operand3 > 범용 레지스터 이용
2. 주소 지정방식 종류
    <table>
        <tr>
            <td>암시적(묵시적)주소 지정 방식(Implied Mode)</td>
            <td>주소를 지정하는 필드가 없는 0 번지 명령어에서 Stack의 SP 가 가리키는 Operand를 암시하여 이용함</td>
        </tr>
        <tr>
            <td>즉시적 주소 지정방식(Immediate Mode)</td>
            <td>명령어 자체에 오퍼랜드(실제 데이터)를 내포하고 있는 방식
            <br>별도의 기억장소를 액세스하지 않고 CPU에서 곧바로 자료를 이용할 수 있어서 실행속도가 빠르다는 장점이 있음
            <br>명령어의 길이에 영향을 받으므로 표현할 수 있는 데이터 값의 범위가 제한적임</td>
        </tr>
        <tr>
            <td>직접 주소 지정방식(Direct Mode)</td>
            <td>명령의 주소부(Operand)가 사용할 자료의 번지를 표현하고 있는 방식 명령의 Operand 부에 표현된 주소를 이용하여 실제 데이터가 기억된 기억 장소에 직접 사상시킬 수 있음
            <br>기억 용량이 2n개의 Word인 메모리 시스템에서 주소를 표현하려면 n 비트의 Operand 부가 필요함</td>
        </tr>
        <tr>
            <td>간접 주소 지정 방식(Indirect Mode)</td>
            <td>명령어에 나타낼 주소가 명령어 내에서 데이터를 지정하기 위해 할당된 비트(Operand 부의 비트)수로 나타낼 수 없을 때 사용하는 방식<br>명령의 길이가 짧고 제한되어 있어도 긴 주소에 접근 가능함<br>명령어 내의 주소부에 실제 데이터가 저장된 장소의 번지를 가진 기억장소의 번지를 표현함으로써, 최소한 주기억 장치를 두 번 이상 접근하여 데이터가 있는 기억장소에 도달함</td>
        </tr>
        <tr>
            <td>계산에 의한(상대)주소 지정 방식</td>
            <td>상대 주소 지정 방식 : 명령어의 주소 부분 +PC<br>Base Register Mode :명령어의 주소 부분 + Base Register <br> Index REgister Mode :  명령어의 주소 부분 + Index Register</td>
        </tr>
    </table>
3. 기억장치 관리 기법
    <table>
        <tr>
            <td>FIFO</td>
            <td>가장 처음에 기록된 페이지를 교체</td>
        </tr>
        <tr>
            <td>LRU</td>
            <td>가장 오랫동안 참조되지 않은 페이지를 교체</td>
        </tr>
        <tr>
            <td>LFU</td>
            <td>사용 횟수가 가장 적은 페이지를 교체</td>
        </tr>
        <tr>
            <td>MRU</td>
            <td>사용 빈도가 가장 많은 페이지를 교체</td>
        </tr>
    </table>
4. 프로세스(process) 개념
   1. 현재 실행 중인 프로그램임
   2. 준비(ready) 상태 : CPU를 할당받기 위해 기다리는 상태임
   3. 실행(running) 상태 : 현재 실행 중인 상태임
   4. 대기, 보류(block) 상태 :입출력(I/O) 처리나 어떤 사건이 일어나길 기다리는 상태(보류)임
5. 스케줄링 개념
   1. 컴퓨터의 자원을 보다 효율적으로 이용하기 위해 작업의 순서와 시간을 할당하는 것임
   2. 선점형과 비선점형이 있음
6. 선점(Preemptive) 스케줄링
   1. 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법임
   2. 우선 순위가 높은 프로세스를 빠르게 ㅎ처리할 수 있음
   3. 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용됨
   4. 종류 : SRT, 선점 우선 순위, Round Robin, 다단계 큐, 다단계 피드백 큐 등의 알고리즘
    <table>
        <tr>
            <th colspan=2>선점형</th>
        </tr>
        <tr>
            <td>RR</td>
            <td>차례대로 일정시간 할당<br>시분할 시스템</td>
        </tr>
        <tr>
            <td>SRT</td>
            <td>남은 처리시간이 가장 짧은 프로세스에 CPU 할당</td>
        </tr>
        <tr>
            <td>MFQ</td>
            <td>높은 단계는 할당량을 적게 낮은 단계는 높게</td>
        </tr>
    </table>
7. 비선점(Non-preemptive) 스케줄링
   1. 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
   2. 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용함
   3. 모든 프로세스에 대한 요구를 공정하게 처리할 수 있음
   4. 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합함
   5. 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있음
   6. 종류: FCFS,SJF, HRN, 기한부 등의 알고리즘
    <table>
        <tr>
            <th colspan=2>비선점</th>
        </tr>
        <tr>
            <td>FIFO</td>
            <td>먼저 들어온 것을 먼저 처리</td>
        </tr>
        <tr>
            <td>SJF</td>
            <td>처리 시간이 가장 짧은 것부터 처리</td>
        </tr>
        <tr>
            <td>HRN</td>
            <td>작업 시간이 짧은 작업의 우선순위가 높지만 긴 작업도 오래 기다리면 우선 순위가 높아짐</td>
        </tr>
    </table>
8. 마이크로 오퍼레이션(Micro Operation)
   1. Instruction을 수행하기 위해 CPU 내의 레지스터와 플래그가 의미 있는 상태 변환을 하도록 하는 동작
   2. 레지스터에 저장된 데이터에 의해 이루어지는 동작
   3. 한 개의 Clock 펄스 동안 실행되는 기본 동작
   4. 마이크로 오퍼레이션의 순서를 결정하기 위하여 제어 장치가 발생하는 신호를 제어신호라고 함
   5. 한 개의 Instruction은 여러 개의 Micro Operation이 동작되어 실행됨
   6. Micro Cycle Time : 한 개의 Micro Operation을 수행하는 데 걸리는 시간
    - 인출 사이클 > 인출 사이클/ 간접 사이클/ 실행 사이클
    - 간접 사이클 > 인출 사이클/ 실행 사이클
    - 실행 사이클 > 인출 사이클/인터럽트 사이클
    - 인터럽트 사이클 > 인출 사이클
9. Micro Cycle Time 부여 방식
    <table>
        <tr>
            <td>동기 고정식(Synchronous fixed)</td>
            <td>모든 마이크로 오퍼레이션의 동작 시간이 같다고 가정하여 CPU Clock의 주기를 Micro Cycle Time과 같도록 정의하는 방식
            <br>모든 마이크로 오퍼레이션 중에서 수행 시간이 가장 긴 마이크로 오퍼레이션의 동작 시간을 Micro Cycle Time으로 정함
            <br>모든 마이크로 오퍼레이션의 동작 시간이 비슷할 때 유리한 방식임
            <br>장점: 제어기의 구현이 단순함
            <br>단점: cPU의 시간 낭비가 심함</td>
        </tr>    
        <tr>
            <td>동기 가변식(Synchronous Variable)</td>
            <td>수행 시간이 유사한 Micro Operation끼리 그룹을 만들어, 각 그룹별로 서로 다른 Micro Cycle Time을 정의하는 방식
            <br>동기 고정식에 비해 CPU 시간 낭비를 줄일 수 있는 반면, 제어기의 구현은 조금 복잡함
            <br>마이크로 오퍼레이션의 동작 시간이 ㅏ이가 날 때 유리함(정수배)</td>
        </tr>
        <tr>
            <td>비동기식(Asynchronous)</td>
            <td>모든 마이크로 오퍼레이션에 대하여 서로 다른 Micro Cycle Time을 정의하는 방식
            <br>CPU의 시간 낭비는 전혀 없으나, 제어기가 매우 복잡해지기 때문에 실제로는 거의 사용되지 않음</td>
        </tr>
    </table>