## 바이너리 인덱스 트리(Binary Indexed Tree)
### 데이터 업데이트가 가능한 상황에서의 구간 합(Interval Sum)문제
- 어떤 N개의 수가 주어져 있다 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려한다. 만약에 1,2,3,4,5라는 수가 있고 3번째 수를 6으로 바꾸고 2번째부터 5번째 까지 합을 구하면 17을 출력하고, 이 상태에서 다섯번째 수를 2로 바꾸고 3번째부터 5번째 까지 합을 구하면 12를 출력한다.
- 데이터 개수: N(1$\leq$N$\leq$1,000,000)
- 데이터 변경 횟수 : M(1$\leq$M$\leq$10,000)
- 구간 합 계산 횟수 : K(1$\leq$K$\leq$10,000)
- 이 문제의 해결방식은?

### 바이너리 인덱스 트리(Binary Indexed Tree)
- 바이너리 인덱스 트리(Binary Indexed Tree)는 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조를 의미.
  - 펜윅 트리(Fenwick tree)라고도 함
- 정수에 따른 2진수 표기
<table>
    <tr>
        <th>정수</th><th>2진수 표기</th>
    </tr>
    <tr>
        <td>7</td><td>00000000 00000000 00000000 0000111</td>
    </tr>
    <tr>
        <td>-7</td><td>11111111 11111111 11111111 1111001</td>
    </tr>
</table>

- 0이 아닌 마지막 비트를 찾는 방법
  - 특정한 숫자 K의 0이 아닌 마지막 비트를 찾기 위해서 K&-K를 계산하면 된다

### 바이너리 인덱스 트리:트리 구조 만들기
- 트리 구조 만들기 : 0이 아닌 마지막 비트 = 내가 저장하고 있는 값들의 개수
- 특정 값을 변경할때 : 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경
- 1부터 N까지의 합(누적 합)구하기: 0이 아닌 마지막 비트만큼 빼면서 구간들의 합 계산
- 이렇게 계산하면 두개씩 나눠지기 때문에 시간복잡도 O(n)= logn의 크기를 갖게 됨
